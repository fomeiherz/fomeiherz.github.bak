<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">















  <link rel="alternate" href="/atom.xml" title="一叶知秋的博客">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="https://blog.fomeiherz.top/page/3/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"一叶知秋的博客","subtitle":"不迷失，不彷徨","description":null,"author":"Fomeiherz","language":"zh-Hans","timezone":null,"url":"https://blog.fomeiherz.top","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/fomeiherz/fomeiherz.github.io.git","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"search":{"path":"search.xml","field":"post","format":"html","limit":"10000"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"since":2015,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>"},"reward":{"enable":false,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"your@email.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/ahonn","weibo":null,"zhihu":null,"douban":null,"pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":null,"changyan":{"appid":null,"appkey":null},"livere_datauid":null,"version":"2.9.0"};
</script>

    <title> 一叶知秋的博客 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">一叶知秋的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">一叶知秋的博客</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/30/自考中大实践课程【归档】/">自考中大实践课程【归档】</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-30
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="实践样题"><a href="#实践样题" class="headerlink" title="实践样题"></a>实践样题</h3><ul>
<li><a href="http://p7240jy2w.bkt.clouddn.com//sysu/pdf/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf" target="_blank" rel="noopener">数据结构</a></li>
<li><a href="http://p7240jy2w.bkt.clouddn.com//sysu/pdf/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.pdf" target="_blank" rel="noopener">操作系统</a></li>
<li><a href="http://p7240jy2w.bkt.clouddn.com//sysu/pdf/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.pdf" target="_blank" rel="noopener">软件工程</a></li>
<li><a href="http://p7240jy2w.bkt.clouddn.com//sysu/pdf/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.pdf" target="_blank" rel="noopener">C++程序设计</a></li>
<li><a href="http://p7240jy2w.bkt.clouddn.com//sysu/pdf/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.pdf" target="_blank" rel="noopener">数据库系统原理</a></li>
<li><a href="http://p7240jy2w.bkt.clouddn.com//sysu/pdf/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.pdf" target="_blank" rel="noopener">Java语言程序设计</a></li>
<li><a href="http://p7240jy2w.bkt.clouddn.com//sysu/pdf/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.pdf" target="_blank" rel="noopener">高级语言程序设计</a></li>
</ul>
<h3 id="C-快速入门"><a href="#C-快速入门" class="headerlink" title="C++快速入门"></a>C++快速入门</h3><ul>
<li><a href="http://p7240jy2w.bkt.clouddn.com/cpp_quick_guide.pdf" target="_blank" rel="noopener">tutorial spoint 教程</a></li>
</ul>
<h3 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h3><ul>
<li><a href="https://blog.fomeiherz.top/2018/05/02/T-SQL%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B/">T-SQL语法示例</a></li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="【线性表】"><a href="#【线性表】" class="headerlink" title="【线性表】"></a>【线性表】</h4><ul>
<li><a href="https://blog.fomeiherz.top/2018/04/27/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/">线性表的顺序存储</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/21/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">线性表的链式存储结构</a></li>
</ul>
<h4 id="【栈】"><a href="#【栈】" class="headerlink" title="【栈】"></a>【栈】</h4><ul>
<li><a href="https://blog.fomeiherz.top/2018/05/02/%E6%A0%88/">栈</a></li>
</ul>
<h4 id="【队列】"><a href="#【队列】" class="headerlink" title="【队列】"></a>【队列】</h4><ul>
<li><a href="https://blog.fomeiherz.top/2018/05/10/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">队列的链式存储结构</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/27/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/">循环队列</a></li>
</ul>
<h4 id="【树】"><a href="#【树】" class="headerlink" title="【树】"></a>【树】</h4><ul>
<li><a href="https://blog.fomeiherz.top/2018/04/21/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></li>
</ul>
<h4 id="【图】"><a href="#【图】" class="headerlink" title="【图】"></a>【图】</h4><ul>
<li><a href="https://blog.fomeiherz.top/2018/04/22/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8/">无向图的邻接表存储</a></li>
</ul>
<h4 id="【查找】"><a href="#【查找】" class="headerlink" title="【查找】"></a>【查找】</h4><ul>
<li><a href="https://blog.fomeiherz.top/2018/04/23/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/">二分法查找</a></li>
</ul>
<h4 id="【排序】"><a href="#【排序】" class="headerlink" title="【排序】"></a>【排序】</h4><ul>
<li><a href="https://blog.fomeiherz.top/2018/04/23/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E5%90%AB%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89/">冒泡排序（含快速排序）</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/24/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E5%90%AB%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%89/">插入排序（含希尔排序）</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/24/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E5%90%AB%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%89/">选择排序（含堆排序）</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/25/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">基数排序</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/30/%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%B1%E6%8E%92%E5%BA%8F%EF%BC%89/">桶排序（箱排序）</a></li>
<li><a href="https://blog.fomeiherz.top/2018/04/30/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">计数排序</a></li>
<li><a href="https://blog.fomeiherz.top/2018/05/11/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/">各种排序算法比较</a></li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/30/计数排序/">计数排序</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-30
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong> 计数排序 </strong> (Counting sort)是一种算法复杂度O(n)的排序方法，适合于小范围集合的排序。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>假设我们有[1,2,3,1,0,4]这6个数，范围是0~4，我们就取出5个箱子，箱子的编号就是代表原数组的元素。分配数字到各个箱子。分配完了后，0号箱有1个元素；1号箱有2个元素，2号箱有1个元素，2号箱有1个元素，4号箱有1个元素。然后依次取出箱的元素，放在新的数组，排序结束。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/30/桶排序（箱排序）/">桶排序（箱排序）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-30
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>桶排序(Bucket sort)或所谓的箱排序的原理是将数组分到有限数量的桶子里边，然后对每个桶再分别排序，最后将各个桶的数据有序的合并起来。  </p>
<h3 id="视频图解"><a href="#视频图解" class="headerlink" title="视频图解"></a>视频图解</h3><p>链接：<a href="https://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BucketSort.html</a>  </p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>设有数组[29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，可以设置5个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49。然后分别将这些数放人自己所属的桶，如下图所示。<br><img src="http://p7240jy2w.bkt.clouddn.com/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C.png" alt="avata"></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/27/线性表的顺序存储/">线性表的顺序存储</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-27
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="存储示意图"><a href="#存储示意图" class="headerlink" title="存储示意图"></a>存储示意图</h3><p><img src="http://p7240jy2w.bkt.clouddn.com/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="avata"></p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>InitList(*L)<br>  操作结果：构造一个空的线性表。</p>
<p>InsertElem(*L, i, e)<br>  初始条件：线性表L存在；1 &lt;= i &lt;= ListLength(L) + 1<br>  操作步骤：判满；从后往前移出第i个位置；L的长度 + 1</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define INIT_SIZE 10</span><br><span class="line">#define INCREASE_SIZE 5</span><br><span class="line"></span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">// 线性表的顺序存储结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    DataType *data; // 元素数组</span><br><span class="line">    int size; // 分配的长度</span><br><span class="line">    int length; // 当前长度</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">// 初始化线性表</span><br><span class="line">int InitList(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    L-&gt;data = (DataType*)malloc(INIT_SIZE * sizeof(DataType));</span><br><span class="line">    if (!L-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;size = INIT_SIZE;</span><br><span class="line">    L-&gt;length = 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在第i个位置插入元素</span><br><span class="line">int InsertElem(SqList *L, int i, DataType e)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 顺序表已满</span><br><span class="line">    if (L-&gt;length &gt;= L-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        // 重新申请空间</span><br><span class="line">        // realloc(源地址, 新的空间)</span><br><span class="line">        DataType* newList;</span><br><span class="line">        newList = (DataType*)realloc(L-&gt;data, (L-&gt;length + INCREASE_SIZE) * sizeof(DataType));</span><br><span class="line">        if (!L-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;data = newList;</span><br><span class="line">        // 修改分配的长度</span><br><span class="line">        L-&gt;size = L-&gt;length + INCREASE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在第i个位置插入</span><br><span class="line">    // i从1开始的，不是从0</span><br><span class="line">    i = i - 1;</span><br><span class="line">    for (int j = L-&gt;length - 1; j &gt;= i; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        // 移动元素</span><br><span class="line">        L-&gt;data[j + 1] = L-&gt;data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i] = e;</span><br><span class="line">    L-&gt;length++;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    InitList(&amp;L);</span><br><span class="line">    InsertElem(&amp;L, 1, 1);</span><br><span class="line">    InsertElem(&amp;L, 1, 2);</span><br><span class="line">    InsertElem(&amp;L, 1, 3);</span><br><span class="line">    InsertElem(&amp;L, 1, 4);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 5);</span><br><span class="line">    InsertElem(&amp;L, 1, 1);</span><br><span class="line">    InsertElem(&amp;L, 1, 2);</span><br><span class="line">    InsertElem(&amp;L, 1, 3);</span><br><span class="line">    InsertElem(&amp;L, 1, 4);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/27/循环队列/">循环队列</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-27
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>顺序图</strong> 的各种存储情况，如下图所示。<br><img src="http://p7240jy2w.bkt.clouddn.com/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E6%83%85%E5%86%B5%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="avata"><br>如果使用顺序表作为队列的话，当处于上图的最右图状态时，不能再继续插入元素，否则会因为数组越界而导致程序异常。假溢出：队列中还有可用的空间，却无法使用。</p>
<p>由此产生了由链表实现的 <strong>循环队列 </strong>，只有队列未满时才可以插入新的队尾元素。<br><strong> 循环队列 </strong>(Circular Queue)的存储结构，如下图所示。<br><img src="http://p7240jy2w.bkt.clouddn.com/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="avata"></p>
<p>简单描述：</p>
<ul>
<li>入队时，尾指针Q.rear追上头指针Q.front，队列已满。</li>
<li>出队时，头指针Q.front追上尾指针Q.rear，队列为空。</li>
</ul>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>InitQueue(*Q)<br>操作步骤：申请内存空间；头尾指针都指向0位置</p>
<p>IsFull(Q)<br>操作步骤：(尾指针 + 1) % 队列长度 == 头指针</p>
<p>EnQueue(Q, e)<br>操作步骤：判满；设置元素；尾指针 + 1</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// 队列：尾部插入，头部删除</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define QUEUE_SIZE 100</span><br><span class="line">#define OVERFLOW -2</span><br><span class="line">#define ERROR -1</span><br><span class="line">#define OK 1</span><br><span class="line"></span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">// 数据结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    DataType *data; // 存放元素</span><br><span class="line">    int front, rear; // 头指针，尾指针</span><br><span class="line">&#125; CircleQueue;</span><br><span class="line"></span><br><span class="line">// 初始化队列</span><br><span class="line">// 头指针和尾指针都指向第0个元素</span><br><span class="line">int InitQueue(CircleQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    // 申请内存空间</span><br><span class="line">    Q-&gt;data = (DataType *)malloc(QUEUE_SIZE * sizeof(DataType));</span><br><span class="line">    if (!Q-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Q-&gt;front = Q-&gt;rear = 0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 少用一个元素空间，也即是尾指针指向的元素始终为空</span><br><span class="line">// 队列是否已满</span><br><span class="line">int IsFull(CircleQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    return (Q-&gt;rear + 1) % QUEUE_SIZE == Q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否为空队列</span><br><span class="line">int IsEmpty(CircleQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    return Q-&gt;front == Q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入队</span><br><span class="line">int EnQueue(CircleQueue *Q, DataType e)</span><br><span class="line">&#123;</span><br><span class="line">    // 判断队列是否已满</span><br><span class="line">    if (IsFull(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        return OVERFLOW;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置元素值</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;</span><br><span class="line">    // 尾指针向前移动一位</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + 1) % QUEUE_SIZE;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建队列</span><br><span class="line">    CircleQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    // 入队</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        EnQueue(&amp;Q, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印</span><br><span class="line">    DataType *data = Q.data;</span><br><span class="line">    int k = Q.front;</span><br><span class="line">    while (k % QUEUE_SIZE != Q.rear)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, data[k]);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/25/基数排序/">基数排序</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-25
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p><strong>基数排序</strong> 是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。<br>个位数分类后各个桶的情况，如下图所示。<br><img src="http://p7240jy2w.bkt.clouddn.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%B8%AA%E4%BD%8D%E6%95%B0%E5%88%86%E7%B1%BB%E5%90%8E%E5%90%84%E4%B8%AA%E6%A1%B6%E7%9A%84%E6%83%85%E5%86%B5.png" alt="avata"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">// 取指定位数的数字</span><br><span class="line">// position是数位</span><br><span class="line">int getPositionNum(int num, int position)</span><br><span class="line">&#123;</span><br><span class="line">    return (int)(num / pow(10.0, position - 1)) % 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bitNum是数位个数</span><br><span class="line">// n是数字个数</span><br><span class="line">void RadixSort(int *arr, int bitNum, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int radix = 10;</span><br><span class="line">    int *count, *bucket, i, j, k;</span><br><span class="line">    // 初始化10个桶，每个桶有各自编号，编号是0~9，分别对应数位数字。桶装的是各个数位数字的个数</span><br><span class="line">    count = (int *) malloc(sizeof(int) * radix);</span><br><span class="line">    // </span><br><span class="line">    bucket = (int *) malloc(sizeof(int) * n);</span><br><span class="line">    for (int k = 1; k &lt;= bitNum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化各个桶为0个</span><br><span class="line">        for (int i = 0; i &lt; radix; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 统计第k个数位数字的个数</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 查询第k位存放的数字</span><br><span class="line">            int num = getPositionNum(arr[i], k);</span><br><span class="line">            // 该数字的数量 + 1</span><br><span class="line">            count[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; radix; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] = count[i] + count[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            j = getPositionNum(arr[i], k);</span><br><span class="line">            bucket[count[j] - 1] = arr[i];</span><br><span class="line">            count[j]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0, j = 0; i &lt; n; i++, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;1,3,4,6&#125;;</span><br><span class="line">    RadixSort(arr, 1, 4);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/25/归并排序/">归并排序</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-25
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>MergeSort(int *array, int low, int high)方法<br>第一步：拆分<br>第二步：左半部分递归拆分<br>第三步：右半部分递归拆分<br>第四步：调用方法Merge()进行排序和合并</p>
<p>Merge(int *array, int low, int mid, int high)方法<br>第一步：新建一个临时数组<br>第二步：分别从左右两边有序取数据，插入到新的数组<br>第三步：复制新数组的内容（下标0~length）到原数组（下标low~high）中</p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><strong>归并排序</strong>分割和合并过程，如下图所示。<br><img src="http://p7240jy2w.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B.png" alt="avata"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 按顺序进行合并2个有序区</span><br><span class="line">void Merge(int *source, int low, int mid, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = low, j = mid + 1, p = 0;</span><br><span class="line">    int *target; // 合并后的有序区</span><br><span class="line">    target = (int *) malloc(sizeof(int) * (high - low + 1));</span><br><span class="line">    if (!target)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // i &gt; mid || j &gt; high 条件成立时，结束</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果第i个元素 &lt;= 第j个元素，则取小的元素出来，并且自增一位</span><br><span class="line">        target[p++] = (source[i] &lt;= source[j]) ? source[i++] : source[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 左半部分未遍历完</span><br><span class="line">    while (i &lt;= mid) </span><br><span class="line">    &#123;</span><br><span class="line">        target[p++] = source[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 右半部份未遍历完</span><br><span class="line">    while (j &lt;= high) </span><br><span class="line">    &#123;</span><br><span class="line">        target[p++] = source[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 把结果复制到原数组中</span><br><span class="line">    // p是从第0个下标开始插入元素的</span><br><span class="line">    p = 0;</span><br><span class="line">    for (i = low; i &lt;= high; i++, p++)</span><br><span class="line">    &#123;</span><br><span class="line">        source[i] = target[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第一步：拆分</span><br><span class="line">// 第二步：左半部分递归拆分</span><br><span class="line">// 第三步：右半部分递归拆分</span><br><span class="line">// 第四步：排序并且合并</span><br><span class="line">void MergeSort(int *source, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    // 用分治法对source[low...high]进行二路归并</span><br><span class="line">    int mid;</span><br><span class="line">    if (low &lt; high) </span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / 2; // 一分为二</span><br><span class="line">        MergeSort(source, low, mid); // 左半部分一分为二，进行排序</span><br><span class="line">        MergeSort(source, mid + 1, high); // 右半部份一分为二，进行排序</span><br><span class="line">        Merge(source, low, mid, high); // 将2个有序区合并成一个有序区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr [] = &#123;4,5,2,1&#125;;</span><br><span class="line"></span><br><span class="line">    MergeSort(arr, 0, 3);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/25/cplusplus基础入门/">C++基础入门</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-25
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 标准库头文件</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// 使用命名空间概念</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line"></span><br><span class="line">int outBool()</span><br><span class="line">&#123;</span><br><span class="line">    bool isAlpha;</span><br><span class="line">    isAlpha = false;</span><br><span class="line">    if (!isAlpha)</span><br><span class="line">    &#123;</span><br><span class="line">        // 默认是以0或1输出布尔值</span><br><span class="line">        std::cout &lt;&lt; &quot;isAlpha = &quot; &lt;&lt; isAlpha &lt;&lt; std::endl;</span><br><span class="line">        // 以true或false输出布尔值</span><br><span class="line">        std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;isAlpha = &quot; &lt;&lt; isAlpha &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义全局变量</span><br><span class="line">// int v1 = 20;</span><br><span class="line"></span><br><span class="line">// 变量的引用作为参数传入，调用时只需要传入普通变量即可</span><br><span class="line">void swap(int&amp; a, int&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 输出Aloha world!</span><br><span class="line">    // endl是输出换行意思</span><br><span class="line">    // cout &lt;&lt; &quot;Aloha world!&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 显式转换数据类型static_case&lt;double&gt;</span><br><span class="line">    // cout &lt;&lt; static_cast&lt;double&gt;(1) / 2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // int v1 = 5;</span><br><span class="line">    // cout &lt;&lt; &quot;打印局部变量值 = &quot; &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line">    // :: 打印全局变量</span><br><span class="line">    // cout &lt;&lt; &quot;打印全局变量值 = &quot; &lt;&lt; ::v1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // inline内联函数</span><br><span class="line">    // 如 inline int max(int a, int b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 引用作为参数</span><br><span class="line">    /*int a1 = 10;</span><br><span class="line">    int a2 = 20;</span><br><span class="line">    cout &lt;&lt; &quot;交换前：a1 = &quot; &lt;&lt; a1 &lt;&lt; &quot; a2 = &quot; &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">    swap(a1, a2);</span><br><span class="line">    cout &lt;&lt; &quot;交换后：a1 = &quot; &lt;&lt; a1 &lt;&lt; &quot; a2 = &quot; &lt;&lt; a2 &lt;&lt; endl;*/</span><br><span class="line"></span><br><span class="line">    // C++创建对象</span><br><span class="line">    // 创建一个char对象，并且初始值是97</span><br><span class="line">    // char* s = new char(97);</span><br><span class="line">    // 创建一个长度为10的数组对象</span><br><span class="line">    // int* p = new int[10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // C++ 定义常量</span><br><span class="line">    //const int ARRAY_SIZE = 10;</span><br><span class="line">    //int arr[ARRAY_SIZE];</span><br><span class="line">    //int x = 1;</span><br><span class="line">    // 定义常量指针</span><br><span class="line">    //const int* p1;</span><br><span class="line">    //p1 = &amp;x;</span><br><span class="line">    // *p1 = 10;</span><br><span class="line">    // 定义指针常量</span><br><span class="line">    //int* const p2 = &amp;x;</span><br><span class="line">    //int y = 10;</span><br><span class="line">    //p2 = &amp;y;</span><br><span class="line">    // const在前先读，const在前不变</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/24/选择排序（含堆排序）/">选择排序（含堆排序）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-24
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>第一趟：在所有元素中选出最小元素。把它和第1个元素进行位置交换。<br>第二趟：在第2个元素 到 最后一个元素中，选出最小元素。把它和第2个元素交换。<br>…<br>依次类推，直到最后一个元素。</p>
<h4 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h4><p><img src="http://p7240jy2w.bkt.clouddn.com/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png" alt="avata"></p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 简单选择排序</span><br><span class="line">// 基本思想：通过n - 1次数据元素的比较，从n - i + 1个记录中选择最小的数据，并与第i个数据进行交换</span><br><span class="line">int SelectSort(int * arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    // 遍历n - 1次就可以了</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 假定第一个为最小值</span><br><span class="line">        int min = arr[i], minIndex = i;</span><br><span class="line">        // 从第二个数开始取</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 跟最小值比较。小了，则重新赋值</span><br><span class="line">            if (arr[j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">                min = arr[minIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把最小值移到有序序列的末端</span><br><span class="line">        arr[minIndex] = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n = 10;</span><br><span class="line">    int arr[10] = &#123;54,675,635,5634,243, 432,13,341,132,341&#125;;</span><br><span class="line">    SelectSort(arr, n);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>堆排序</strong>是一种树形选择排序，在排序过程中可以把元素看成一颗完全二叉树，每个节点都大（小）于他的两个子结点。当每个节点都大于等于它的两个子结点时，称为大顶堆；否则为小顶堆。</p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">//堆排序（HeapSort）  </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//堆调整，构建大顶堆，arr[]是待调整的数组，i是待调整的数组  </span><br><span class="line">//元素的位置，length是数组的长度  </span><br><span class="line">void HeapAdjust(int arr[], int i, int length) </span><br><span class="line">&#123;</span><br><span class="line">    int Child;</span><br><span class="line">    int temp;</span><br><span class="line">    for (; 2 * i + 1 &lt; length; i = Child) </span><br><span class="line">    &#123;</span><br><span class="line">        //子节点的位置 = 2 * (parent(父结点)) + 1  </span><br><span class="line">        Child = 2 * i + 1;</span><br><span class="line">        //得到子结点中较大的结点  </span><br><span class="line">        if(Child &lt; length - 1 &amp;&amp; arr[Child + 1] &gt; arr[Child]) </span><br><span class="line">        &#123;</span><br><span class="line">            ++Child;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果较大的子结点大于父结点那么把较大的子结点往上移动  </span><br><span class="line">        //替换它的父结点  </span><br><span class="line">        if(arr[i] &lt; arr[Child]) </span><br><span class="line">        &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[Child];</span><br><span class="line">            arr[Child] = temp;</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//堆排序算法  </span><br><span class="line">void HeapSort(int arr[], int length) </span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    //调整序列的前半部分元素，调整完之后第一个元素  </span><br><span class="line">    //是序列的最大元素，length/2-1是最后一个非叶子结点  </span><br><span class="line">    for (i = length / 2 - 1; i &gt;= 0; --i) </span><br><span class="line">	&#123; </span><br><span class="line">		HeapAdjust(arr, i, length);</span><br><span class="line">	&#125;</span><br><span class="line">    //从最后一个元素开始对序列进行调整，不断的缩小调整  </span><br><span class="line">    //的范围直到第一个元素  </span><br><span class="line">    //循环里是把第一个元素和当前的最后一个元素交换  </span><br><span class="line">    //保证当前的最后一个位置的元素是现在这个序列的最大的  </span><br><span class="line">    //不断的缩小调整heap的范围，每一次调整完毕保证第一个  </span><br><span class="line">    //元素是当前序列的最大的元素  </span><br><span class="line">    for (i = length - 1; i &gt; 0; --i) </span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = arr[0]^arr[i];</span><br><span class="line">        arr[0] = arr[0]^arr[i];</span><br><span class="line">        arr[i] = arr[0]^arr[i];</span><br><span class="line">        HeapAdjust(arr, 0, i); //递归调整</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int num[] = &#123;98, 48, 777, 63, 57, 433, 23, 1112, 1&#125;;</span><br><span class="line">    printf(&quot;待排序的数据是：&quot;);</span><br><span class="line">    for (i = 0; i &lt; sizeof(num) / sizeof(int); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    HeapSort(num, sizeof(num) / sizeof(int));</span><br><span class="line">    printf(&quot;排序后的数据是：&quot;);</span><br><span class="line">    for (i = 0; i &lt; sizeof(num) / sizeof(int); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/24/指针基本概念/">指针基本概念</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-24
        </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 指针的基本定义</span><br><span class="line">void PointerDefine()</span><br><span class="line">&#123;</span><br><span class="line">    // 指针变量存放的另一种变量的地址</span><br><span class="line">    int a1 = 100;</span><br><span class="line">    int a2 = 20;</span><br><span class="line">    // 定义整形数据的指针变量</span><br><span class="line">    int *p1, *p2;</span><br><span class="line">    // 把指针p1指向a1变量</span><br><span class="line">    p1 = &amp;a1;</span><br><span class="line">    p2 = &amp;a2;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%p, %p\n&quot;, p1, p2); // 输出a1，a2所在内存中的地址</span><br><span class="line">    printf(&quot;%d, %d\n&quot;, *p1, *p2); // 输出p1，p2指向变量对应的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编写程序，输入2个整数，按先大后小的顺序输出a和b</span><br><span class="line">// 思路：用指针的方法处理这个问题，不交换整形变量的值，而是交换指针变量的值</span><br><span class="line">void SwitchPointer()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    printf(&quot;请输入2个整数：&quot;);</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    int *pa = &amp;a, *pb = &amp;b;</span><br><span class="line">    if (*pa &lt; *pb) </span><br><span class="line">    &#123;</span><br><span class="line">        int *p = pa;</span><br><span class="line">        pa = pb;</span><br><span class="line">        pb = p;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;由大到小输出2个值：%d  %d&quot;, *pa, *pb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指针变量作为函数参数。作用是将一个变量的地址传送到另一个函数中</span><br><span class="line">// 通过指针变量的传入，可以改变指针所指向的变量的值</span><br><span class="line">void Swap(int *p1, int *p2)</span><br><span class="line">&#123;</span><br><span class="line">    // 交换指针所指向变量的值</span><br><span class="line">    int temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line">// 打印交换前和交换后的值</span><br><span class="line">void PrintSwap()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 111, b = 222;</span><br><span class="line">    printf(&quot;交换前，a = %d，b = %d\n&quot;, a, b);</span><br><span class="line">    Swap(&amp;a, &amp;b);</span><br><span class="line">    printf(&quot;交换后，a = %d，b = %d\n&quot;, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输入3个整数a、b、c，要求按从大到小的顺序将他们输出，用函数实现</span><br><span class="line">// 用exchange函数改变这3个变量的值，用swap函数交换2个变量的值</span><br><span class="line">void exchange(int *p1, int *p2, int *p3)</span><br><span class="line">&#123;</span><br><span class="line">    if (*p1 &lt; *p2)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line">    if (*p1 &lt; *p3) </span><br><span class="line">    &#123;</span><br><span class="line">        Swap(p1, p3);</span><br><span class="line">    &#125;</span><br><span class="line">    if (*p2 &lt; *p3) </span><br><span class="line">    &#123;</span><br><span class="line">        Swap(p2, p3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int a = 2, b = 2, c = 3;</span><br><span class="line">    exchange(&amp;a, &amp;b, &amp;c);</span><br><span class="line">    printf(&quot;从大到小：%d  %d  %d\n&quot;, a, b, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/4/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Fomeiherz</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

  </body>
</html>
